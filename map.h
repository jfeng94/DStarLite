#ifndef MAP_H
#define MAP_H

#include <vector>
#include <queue>
#include <limits.h>
#include <iostream>


struct Point
{
    // Data members
    float x, y;

    // Constructor
    Point() : x(0), y(0) {};
    Point(float X, float Y) {x = X; y = Y;}

    // Operator overrides
    Point operator+ (Point p) {return Point(x + p.x, y + p.y);}
    Point operator- (Point p) {return Point(x + p.x, y + p.y);}
    void  operator+=(Point p) {x += p.x;}
    void  operator-=(Point p) {y += p.y;}
    Point operator= (Point p) {x = p.x; y = p.y; return p;}
};

struct Cell
{
    // Enumeration for status
    enum STATE
    {
        OPEN,
        BLOCKED,
        UNKNOWN
    };

    // Data members
    Point p;
    int xidx, yidx;
    int dist;
    STATE state;

    // Constructors
    Cell(float, float, int, int);
    Cell(Point, int, int);
};

class Map
{
    private:
        // Data members
        std::vector<Cell> map;         // Occupancy grid
        std::vector<Point> path;       // Waypoints generated by A*
        float xmin, xmax, ymin, ymax;  // World dimensions
        float res;                     // Resolution of occupancy grid
        int Nx, Ny;                    // X, Y dimensions of occupancy grid
        int maxDist;                   // For aesthetics
        Point goal;
        Point goal_idx;
            
        // Private functions: Should never be needed outside the class
        Point getIndex(Point p);         // Function that reports where a 
                                       // given point snas to on the 
                                       // occupancy grid

	    Point neighborIndex(Point idx);

	    Point OccupancyToReal(Point p);

        std::vector<Point>
            lineAlgorithm(Point, Point); // Quick implementation
                                         // of Bresenham's Line
                                         // Algorithm

        void enqueueNeighbors                 // Used for updating dist
             (std::queue<Point> &, int, int);

        void updateDistances(Point, Cell::STATE); // Updates dist in map
        int  checkNeighbors(Point);               // Gets min dist of neighbors
        void lineStates(std::vector<Point>);      // Updates states in line
         
    public:
        // I stuck it in public. Suck it.
        std::vector<Point> indices;    // Waypoints in occupancy grid space
        // Constructor
        Map(float, float, float, float, float);

        // Initialize map. Sets default distances from goal.
        void init(Point p);

        // Update occupancy grid based on what the rangefinder sees
        // They use real world points.
        void setBlocked(Point, Point); // These are super important. You need
        void setOpen   (Point, Point); // to update for every rangefinder entry

        // Mutators: Gain access to modifying data members
        // They use occupancy grid world coordinates
        void setState(int, int, Cell::STATE);
        void setDist (int, int, int);

        // Accessors: Get values of data members
        int getNx() {return Nx;}
        int getNy() {return Ny;}
        int getDist(int i, int j) {return map[Nx * j + i].dist;}
        int getDist(Point p) {return map[Nx * p.y + p.x].dist;}
        Point getReal(int i, int j) {return map[Nx * j + i].p;}
        int getMaxDist() {return maxDist;}
        Cell get(int i, int j) {return map[Nx * j + i];}

        // Use this to get the waypoint path that the robot should traverse
        std::vector<Point> getPath() {return path;}

        // LPA implementation
        void AStar(Point);

        // Operator overloading: Lets you print out an image of occupancy grid
        friend std::ostream& operator<<(std::ostream&, Map); 

};
#endif
