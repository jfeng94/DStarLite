#include "map.h"
#include "sensor_msgs/LaserScan.h"
#include "nav_msgs/Odometry.h"
#include "geometry_msgs/Twist.h"
#include <cmath>
#include <climits>
#include <string>
#include <vector>
#include <stdlib.h>
#include <stdio.h>
#include "ros/ros.h"
#include "tf/tf.h"
#include <fstream>
#include <ostream>
#include <istream>

int min_dist = .5;
int scan_number;
bool safe_to_move;
double rangeholder[700];
float min_angle, max_angle, max_range;

double IndexToAngle( int index, const int numAngles, const double min, const double max){
    double angle;
    angle = (max - min)*(double)index/numAngles + min;
    return angle;
}

void laser_cb( const sensor_msgs::LaserScan &scan )
{
    max_range = scan.range_max;
        min_angle = scan.angle_min;
    max_angle = scan.angle_max;
        scan_number = scan.ranges.size();
    for (int i = 0; i < scan.ranges.size(); i++){
        rangeholder[i] = scan.ranges[i];
}
}

class OdomWatcher {
public:

    OdomWatcher( ros::NodeHandle &nh, std::string topic_name = "odom" );

    // Callback function for messages from the "odom" topic
    void odom_cb( const nav_msgs::Odometry &od );

    /* Get current pose estimate
     *
     * If an estimate is available, return true and place the estimate in the
     * given array. Otherwise, return false and do nothing to the array.
     */
    bool get_pose_estimate( double *x );

private:
    double last_opose[3];
    bool valid_opose;
    ros::Subscriber odomsub;
};

OdomWatcher::OdomWatcher( ros::NodeHandle &nh, std::string topic_name )
    : valid_opose(false),
      odomsub(nh.subscribe( topic_name, 1, &OdomWatcher::odom_cb, this ))
{ }

void OdomWatcher::odom_cb( const nav_msgs::Odometry &od )
{
    valid_opose = false;
    last_opose[0] = od.pose.pose.position.x;
    last_opose[1] = od.pose.pose.position.y;
    last_opose[2] = tf::getYaw( od.pose.pose.orientation );
    valid_opose = true;
}

bool OdomWatcher::get_pose_estimate( double *x )
{
    if (valid_opose) {
        for (int i = 0; i < 3; i++)
            x[i] = last_opose[i];
    }
    return valid_opose;
}
void updateMap(Map m, Point Current, double current_angle){
   
}

int main(int argc, char** argv)
{
    float xmin = atof(argv[1]);
    float ymin = atof(argv[2]);
    float xmax = atof(argv[3]);
    float ymax = atof(argv[4]);
    float res  = atof(argv[5]);
    double pointing, current_pose[3];
    Map m(xmin, ymin, xmax, ymax, res);
    double min_reach_err = .2;
    double min_angle_err = .1;
    double forward_speed = .3;
    double turning_rate = .5;
    Point p(1.5,1.5);
    
    m.init(p);
    safe_to_move = true;
    ros::init (argc, argv, "Oscar", ros::init_options::AnonymousName );
    ros::NodeHandle nh;

    ros::Publisher action = nh.advertise<geometry_msgs::Twist>( "cmd_vel", 1);
    ros::Subscriber lmssub = nh.subscribe( "scan", 10, &laser_cb );
    OdomWatcher pose_watcher( nh );
    std::vector<Point> waypoints;
    Point Current;
    double Pointing;
    double angle_diff;
    Current.x = current_pose[0];
    Current.y = current_pose[1];
    int current_index = 0;
ros::Rate rate( 15. );
int k = 0;
std::ofstream out;
while(ros::ok()){
    // Example of how to print out occupancy matrix
    pose_watcher.get_pose_estimate( current_pose );
    geometry_msgs::Twist mot;
   for (int i = 0; i <scan_number; i = i+8){
    Pointing = IndexToAngle(i, scan_number, min_angle, max_angle) + current_pose[2];
    // If the readings have not been initialized yet, do nothing 
    if (Pointing != Pointing){
        printf("NAN!!!!!\n");
    }
    // If the readings HAVE been initialized, include them into the map
      else if ( rangeholder[i] > max_range){
            Point range_edge;
            range_edge.x = max_range * cos( Pointing );
            range_edge.y = max_range * sin( Pointing );
            m.setOpen(Current, range_edge);
            
       }
       else {
            Point range_edge;
            range_edge.x = rangeholder[i] * cos( Pointing );
            range_edge.y = rangeholder[i] * sin( Pointing );
            m.setBlocked(Current, range_edge);
            }
       } 


    m.AStar(Current);
    waypoints = m.getPath();
    
if (safe_to_move){
	angle_diff = atan2( waypoints[current_index].y - current_pose[1], waypoints[current_index].x - current_pose[0] ) - current_pose[2];
if (sqrt( (waypoints[current_index].x - current_pose[0])*(waypoints[current_index].x - current_pose[0]) + (waypoints[current_index].y - current_pose[1])*(waypoints[current_index].y - current_pose[1]) ) < min_reach_err) {
				std::cout << "Reached waypoint " << current_index << std::endl;
				current_index = (current_index+1) % m.path.size();
			} else if (fabs( angle_diff ) > min_angle_err) {

				if (angle_diff > 0) {
					mot.angular.z = turning_rate;
				} else {
					mot.angular.z = -turning_rate;
				}

			} else {
				mot.linear.x = forward_speed;
			}
}
    
    action.publish( mot ); 
    ros::spinOnce();
    rate.sleep();
    k++;
    if (k > 100){
        break;
    }

}

            out.open("test.ppm");
            out << m;
            out.close();
    return 0;
}
